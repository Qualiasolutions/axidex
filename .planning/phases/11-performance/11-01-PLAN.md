---
phase: 11-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/swr.ts
  - src/hooks/use-signals.ts
  - src/hooks/use-emails.ts
  - src/hooks/use-accounts.ts
  - src/hooks/use-rules.ts
  - src/hooks/use-stats.ts
  - src/components/ui/skeleton.tsx
  - src/app/dashboard/signals/page.tsx
  - src/app/dashboard/emails/page.tsx
  - src/app/dashboard/accounts/page.tsx
  - src/app/dashboard/rules/page.tsx
  - src/app/dashboard/page.tsx
autonomous: true

must_haves:
  truths:
    - "Data fetches are cached and deduplicated across components"
    - "Repeat visits load instantly from SWR cache"
    - "All list pages show consistent skeleton loading states"
    - "Skeleton components match the shape of actual content"
  artifacts:
    - path: "src/lib/swr.ts"
      provides: "SWR configuration with cache settings"
      exports: ["swrConfig"]
    - path: "src/hooks/use-signals.ts"
      provides: "SWR hook for signals data"
      exports: ["useSignals"]
    - path: "src/hooks/use-emails.ts"
      provides: "SWR hook for emails data"
      exports: ["useEmails"]
    - path: "src/hooks/use-accounts.ts"
      provides: "SWR hook for accounts data"
      exports: ["useAccounts"]
    - path: "src/hooks/use-rules.ts"
      provides: "SWR hook for rules data"
      exports: ["useRules"]
    - path: "src/hooks/use-stats.ts"
      provides: "SWR hook for dashboard stats"
      exports: ["useStats"]
    - path: "src/components/ui/skeleton.tsx"
      provides: "Reusable skeleton loading components"
      exports: ["Skeleton", "SignalCardSkeleton", "EmailCardSkeleton", "AccountCardSkeleton", "RuleCardSkeleton", "StatCardSkeleton"]
  key_links:
    - from: "src/app/dashboard/signals/page.tsx"
      to: "src/hooks/use-signals.ts"
      via: "useSignals hook import"
      pattern: "useSignals"
    - from: "src/hooks/use-signals.ts"
      to: "src/lib/swr.ts"
      via: "SWR config import"
      pattern: "swrConfig|useSWR"
---

<objective>
Add SWR for client-side data caching and create consistent skeleton loading components.

Purpose: Enable instant page loads on repeat visits, deduplicate requests, and provide consistent loading states across all dashboard pages.

Output: SWR hooks for all data fetching, skeleton component library, and updated pages using these patterns.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/dashboard/signals/page.tsx
@src/app/dashboard/emails/page.tsx
@src/app/dashboard/accounts/page.tsx
@src/app/dashboard/rules/page.tsx
@src/app/dashboard/page.tsx
@src/hooks/use-realtime-signals.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install SWR and create configuration</name>
  <files>package.json, src/lib/swr.ts</files>
  <action>
1. Install SWR package: `npm install swr`

2. Create `src/lib/swr.ts` with SWR configuration:
   - Export a `swrConfig` object with:
     - `revalidateOnFocus: false` (prevent refetch on tab focus)
     - `revalidateOnReconnect: true` (refresh on network reconnect)
     - `dedupingInterval: 5000` (5 second deduplication window)
     - `errorRetryCount: 3` (retry failed requests 3 times)
   - Export a generic fetcher function that:
     - Uses fetch() with credentials: 'same-origin'
     - Throws error for non-ok responses
     - Returns parsed JSON

3. Create SWRConfig wrapper component that applies config to children.
  </action>
  <verify>
- `npm ls swr` shows swr installed
- `src/lib/swr.ts` exists with exports
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>SWR installed and configured with project-wide settings</done>
</task>

<task type="auto">
  <name>Task 2: Create SWR hooks for all data types</name>
  <files>src/hooks/use-signals.ts, src/hooks/use-emails.ts, src/hooks/use-accounts.ts, src/hooks/use-rules.ts, src/hooks/use-stats.ts</files>
  <action>
Create 5 SWR hooks that replace current useEffect fetching:

1. `src/hooks/use-signals.ts` - useSignals hook:
   - Accept params: { types?, priorities?, search?, from?, to?, limit?, offset? }
   - Return { signals, count, isLoading, error, mutate }
   - Build URL from params, use as SWR key
   - Enable revalidation when params change

2. `src/hooks/use-emails.ts` - useEmails hook:
   - Accept params: { tones?, statuses?, search?, from?, to?, limit?, offset? }
   - Return { emails, count, isLoading, error, mutate }

3. `src/hooks/use-accounts.ts` - useAccounts hook:
   - Accept params: { search?, sortBy?, minSignals?, limit?, offset? }
   - Return { accounts, count, isLoading, error, mutate }

4. `src/hooks/use-rules.ts` - useRules hook:
   - Accept params: { active?, limit?, offset? }
   - Return { rules, count, isLoading, error, mutate }

5. `src/hooks/use-stats.ts` - useStats hook:
   - No params needed
   - Return { stats, isLoading, error, mutate }
   - Cache for 30 seconds (refreshInterval: 30000) since stats update slowly

Each hook should:
- Use `useSWR` with fetcher from lib/swr
- Return typed data matching existing types (Signal[], GeneratedEmail[], etc.)
- Expose `mutate` function for optimistic updates (used in Plan 02)
  </action>
  <verify>
- All 5 hook files exist with proper exports
- TypeScript compiles without errors: `npx tsc --noEmit`
- Hooks return correct shape (signals/emails/accounts/rules array + count)
  </verify>
  <done>SWR hooks created for all dashboard data fetching</done>
</task>

<task type="auto">
  <name>Task 3: Create skeleton component library</name>
  <files>src/components/ui/skeleton.tsx</files>
  <action>
Create skeleton components that match the shape of actual cards:

1. Base `Skeleton` component:
   - Accept className prop
   - Render div with `bg-muted animate-pulse rounded` classes
   - Support width/height via className or props

2. `SignalCardSkeleton`:
   - Match SignalCard layout: icon placeholder (48x48), title line, subtitle line, badges row
   - Use rounded-2xl to match actual card

3. `EmailCardSkeleton`:
   - Match EmailCard: subject line (60% width), body lines (3 lines at 100%, 100%, 40%), badges

4. `AccountCardSkeleton`:
   - Match AccountCard: company avatar (40x40), name line, domain line, signal count

5. `RuleCardSkeleton`:
   - Match RuleCard: icon (40x40), name line, description line, toggle placeholder

6. `StatCardSkeleton`:
   - Match StatCard: icon (40x40), label line, value line (larger)

All skeletons should:
- Use consistent spacing (gap-4, p-6) matching actual components
- Have proper border radius (rounded-2xl)
- Use subtle border (border border-border/50) like actual cards
  </action>
  <verify>
- All skeleton exports exist
- Components render without errors
- Visual inspection: skeletons match card shapes (can verify via storybook or page load)
  </verify>
  <done>Skeleton components created matching actual card layouts</done>
</task>

<task type="auto">
  <name>Task 4: Migrate pages to SWR hooks with skeletons</name>
  <files>src/app/dashboard/signals/page.tsx, src/app/dashboard/emails/page.tsx, src/app/dashboard/accounts/page.tsx, src/app/dashboard/rules/page.tsx, src/app/dashboard/page.tsx</files>
  <action>
Update each page to use SWR hooks instead of useState+useEffect:

1. **signals/page.tsx**:
   - Replace useState for signals/loading/error with useSignals hook
   - Remove fetchSignals useEffect
   - Keep searchParams logic for building hook params
   - Replace inline loading skeleton with SignalCardSkeleton (4 instances)
   - Keep keyboard navigation logic (uses signals array from hook)

2. **emails/page.tsx**:
   - Replace useState/useEffect with useEmails hook
   - Replace loading skeleton with EmailCardSkeleton (3 instances)

3. **accounts/page.tsx**:
   - Replace useState/useEffect with useAccounts hook
   - Replace loading skeleton with AccountCardSkeleton (3 instances)

4. **rules/page.tsx**:
   - Replace useState/useEffect with useRules hook
   - Replace loading skeleton with RuleCardSkeleton (3 instances)

5. **page.tsx (dashboard)**:
   - Replace fetchData pattern with useStats and useSignals hooks
   - Update loading state to use StatCardSkeleton (4) and SignalCardSkeleton (4)
   - Keep realtime subscription logic (works alongside SWR)

For each page:
- Remove useState for data/loading/error
- Import and use the corresponding SWR hook
- Destructure { data, isLoading, error, mutate } from hook
- Replace `loading` checks with `isLoading`
- Import skeleton components from ui/skeleton
  </action>
  <verify>
- All pages compile without TypeScript errors
- Run dev server: `npm run dev`
- Navigate to each page - should load data with skeleton first, then real content
- Refresh page - second load should be instant (cached)
- Check browser DevTools Network tab - requests are deduplicated
  </verify>
  <done>All dashboard pages migrated to SWR with consistent skeleton loading</done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. TypeScript passes: `npx tsc --noEmit`
3. All pages load data correctly with skeletons during loading
4. Repeat page visits show instant content (from SWR cache)
5. Network tab shows deduplicated requests within 5s window
</verification>

<success_criteria>
- SWR caches data and serves from cache on repeat visits
- All list pages show skeleton loading states matching card shapes
- Data fetching code is cleaner (hooks vs useState+useEffect)
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance/11-01-SUMMARY.md`
</output>
