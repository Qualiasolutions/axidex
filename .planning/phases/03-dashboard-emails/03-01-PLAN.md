---
phase: 03-dashboard-emails
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/signals/route.ts
  - src/app/dashboard/signals/page.tsx
  - src/lib/queries/signals.ts
autonomous: true

must_haves:
  truths:
    - "User sees real signals from database (not empty states)"
    - "User can filter signals by type (hiring/funding/etc)"
    - "User can filter signals by priority (high/medium/low)"
    - "User can filter signals by date range"
    - "Filters persist in URL for sharing/refresh"
  artifacts:
    - path: "src/app/api/signals/route.ts"
      provides: "GET endpoint for fetching signals with filters"
      exports: ["GET"]
    - path: "src/lib/queries/signals.ts"
      provides: "Supabase query builder for signals"
      exports: ["fetchSignals", "buildSignalsQuery"]
    - path: "src/app/dashboard/signals/page.tsx"
      provides: "Signals list with working filters"
      min_lines: 100
  key_links:
    - from: "src/app/dashboard/signals/page.tsx"
      to: "/api/signals"
      via: "fetch with filter params"
      pattern: "fetch.*api/signals"
    - from: "src/app/api/signals/route.ts"
      to: "supabase.from('signals')"
      via: "database query"
      pattern: "supabase.*from.*signals"
---

<objective>
Wire the signals page to display real data from Supabase with working type, priority, and date filters.

Purpose: Users currently see empty states. This plan connects the frontend to the database so users see actual signals. Filters enable finding relevant signals quickly.

Output: Working signals list page with functional filters that query the database.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/types/index.ts
@src/lib/supabase/server.ts
@src/components/signals/signal-card.tsx
@supabase/migrations/001_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create signals query layer and API route</name>
  <files>
    src/lib/queries/signals.ts
    src/app/api/signals/route.ts
  </files>
  <action>
Create `src/lib/queries/signals.ts`:
- Export `buildSignalsQuery(supabase, filters: SignalFilter, userId: string)` function
- Build Supabase query with optional filters:
  - types: `.in('signal_type', types)` if provided
  - priorities: `.in('priority', priorities)` if provided
  - statuses: `.in('status', statuses)` if provided
  - search: `.or('title.ilike.%${search}%,company_name.ilike.%${search}%')` if provided
  - dateRange: `.gte('detected_at', from).lte('detected_at', to)` if provided
- Always filter by user_id: `.eq('user_id', userId)`
- Order by detected_at DESC
- Default limit 50, accept limit/offset params

Create `src/app/api/signals/route.ts`:
- Export async GET handler
- Parse search params: types, priorities, statuses, search, from, to, limit, offset
- Get authenticated user from Supabase session (return 401 if not authenticated)
- Call buildSignalsQuery with parsed filters
- Return JSON: { signals: Signal[], count: number }
- Handle errors with 500 response

Use existing types from `@/types` (Signal, SignalFilter).
  </action>
  <verify>
`npx tsc --noEmit` passes. API route file exists with GET export.
  </verify>
  <done>
API endpoint `/api/signals` accepts filter params and returns signals from database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire signals page to fetch and display real data</name>
  <files>
    src/app/dashboard/signals/page.tsx
  </files>
  <action>
Rewrite `src/app/dashboard/signals/page.tsx`:

1. Add "use client" directive (already present)
2. Add state for signals, loading, error, and filter values
3. Add useSearchParams() to read filters from URL (wrap in Suspense per D002)
4. Add useEffect to fetch from /api/signals with current filters
5. Wire filter buttons to update URL params via useRouter().push()
6. Show loading skeleton while fetching
7. Show SignalCard components for each signal (already imported pattern)
8. Update stats bar to show real counts from response
9. Show empty state only when signals.length === 0 after load

Filter UI:
- Type filter: clickable badges that toggle (multi-select)
- Priority filter: dropdown or toggle group
- Date filter: simple preset buttons (Today, This Week, This Month, All)
- Search: debounced input field

Use existing components: Button, Badge, SignalCard.
Use cn() for conditional classes.
Keep existing motion animations.
  </action>
  <verify>
`npm run build` succeeds. Navigate to /dashboard/signals, see loading then signals (or empty state if DB empty).
  </verify>
  <done>
Signals page fetches from API and displays real signals. Filter buttons update URL and refetch data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add date range filter with presets</name>
  <files>
    src/app/dashboard/signals/page.tsx
  </files>
  <action>
Enhance the signals page with date filtering:

1. Add date preset buttons: "Today", "This Week", "This Month", "All Time"
2. Each button sets `from` and `to` URL params using date-fns:
   - Today: startOfDay(new Date()), endOfDay(new Date())
   - This Week: startOfWeek(new Date()), endOfWeek(new Date())
   - This Month: startOfMonth(new Date()), endOfMonth(new Date())
   - All Time: no from/to params
3. Highlight active preset based on current URL params
4. Format dates as ISO strings for URL params

Use date-fns (already in package.json): startOfDay, endOfDay, startOfWeek, endOfWeek, startOfMonth, endOfMonth, formatISO.

Place date filters in the filter bar alongside type filters.
  </action>
  <verify>
Click "This Week" filter, URL updates with from/to params, signal list updates to show only signals from this week.
  </verify>
  <done>
Date range filtering works with preset buttons. Users can filter signals by time period.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No type errors
2. `npm run build` - Build succeeds
3. Manual test: Navigate to /dashboard/signals as logged-in user
4. Verify: Signals load from database (or empty state if no signals)
5. Verify: Click type filter -> URL updates -> list filters
6. Verify: Click date preset -> URL updates -> list filters
7. Verify: Refresh page -> filters persist from URL
</verification>

<success_criteria>
- Signals page shows real data from database
- Type filter works (multi-select)
- Priority filter works
- Date preset filters work (Today/Week/Month/All)
- Filters persist in URL
- Loading state displays while fetching
- Empty state shows when no signals match filters
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-emails/03-01-SUMMARY.md`
</output>
