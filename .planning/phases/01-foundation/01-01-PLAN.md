---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/001_schema.sql
  - supabase/migrations/002_rls.sql
  - src/types/database.ts
autonomous: true

must_haves:
  truths:
    - "Database tables exist for signals, emails, and user profiles"
    - "RLS policies prevent users from accessing other users' data"
    - "TypeScript types match database schema"
  artifacts:
    - path: "supabase/migrations/001_schema.sql"
      provides: "Database table definitions"
      contains: "CREATE TABLE signals"
    - path: "supabase/migrations/002_rls.sql"
      provides: "Row-level security policies"
      contains: "CREATE POLICY"
    - path: "src/types/database.ts"
      provides: "Supabase-generated TypeScript types"
      contains: "export type Database"
  key_links:
    - from: "src/types/database.ts"
      to: "supabase schema"
      via: "Supabase CLI type generation"
      pattern: "Database\\['public'\\]"
---

<objective>
Create the database schema and RLS policies for Axidex.

Purpose: Establishes the data foundation that all other features build on. Without tables and security policies, signals cannot be stored and users cannot have isolated data.

Output: SQL migrations ready to apply, TypeScript types generated from schema.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database schema migration</name>
  <files>supabase/migrations/001_schema.sql</files>
  <action>
Create SQL migration with the following tables:

**profiles table** (extends auth.users):
- `id` UUID references auth.users(id) ON DELETE CASCADE, primary key
- `email` TEXT NOT NULL
- `full_name` TEXT
- `avatar_url` TEXT
- `company_name` TEXT
- `created_at` TIMESTAMPTZ DEFAULT now()
- `updated_at` TIMESTAMPTZ DEFAULT now()

**signals table**:
- `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
- `user_id` UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL
- `company_name` TEXT NOT NULL
- `company_domain` TEXT
- `company_logo` TEXT
- `signal_type` TEXT NOT NULL CHECK (signal_type IN ('hiring', 'funding', 'expansion', 'partnership', 'product_launch', 'leadership_change'))
- `title` TEXT NOT NULL
- `summary` TEXT NOT NULL
- `source_url` TEXT NOT NULL
- `source_name` TEXT NOT NULL
- `priority` TEXT NOT NULL CHECK (priority IN ('high', 'medium', 'low'))
- `status` TEXT NOT NULL DEFAULT 'new' CHECK (status IN ('new', 'reviewed', 'contacted', 'converted', 'dismissed'))
- `detected_at` TIMESTAMPTZ NOT NULL DEFAULT now()
- `created_at` TIMESTAMPTZ DEFAULT now()
- `metadata` JSONB DEFAULT '{}'::jsonb

**generated_emails table**:
- `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
- `signal_id` UUID REFERENCES signals(id) ON DELETE CASCADE NOT NULL
- `user_id` UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL
- `subject` TEXT NOT NULL
- `body` TEXT NOT NULL
- `tone` TEXT NOT NULL CHECK (tone IN ('professional', 'casual', 'enthusiastic'))
- `created_at` TIMESTAMPTZ DEFAULT now()

Add indexes:
- `signals(user_id)` - for filtering by user
- `signals(signal_type)` - for filtering by type
- `signals(priority)` - for filtering by priority
- `signals(created_at DESC)` - for chronological sorting
- `generated_emails(signal_id)` - for looking up emails by signal

Create trigger function for auto-creating profile on user signup:
```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name)
  VALUES (new.id, new.email, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

Create updated_at trigger:
```sql
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER profiles_updated_at
  BEFORE UPDATE ON profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```
  </action>
  <verify>SQL file exists and is valid SQL syntax (no runtime errors when parsed)</verify>
  <done>Migration file contains CREATE TABLE for profiles, signals, generated_emails with all columns and constraints</done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies migration</name>
  <files>supabase/migrations/002_rls.sql</files>
  <action>
Create RLS policies that ensure users can only access their own data:

**Enable RLS on all tables:**
```sql
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE signals ENABLE ROW LEVEL SECURITY;
ALTER TABLE generated_emails ENABLE ROW LEVEL SECURITY;
```

**profiles policies:**
- SELECT: Users can view own profile (`auth.uid() = id`)
- UPDATE: Users can update own profile (`auth.uid() = id`)
- INSERT: Handled by trigger (no direct insert needed)

**signals policies:**
- SELECT: Users can view own signals (`auth.uid() = user_id`)
- INSERT: Users can insert signals for themselves (`auth.uid() = user_id`)
- UPDATE: Users can update own signals (`auth.uid() = user_id`)
- DELETE: Users can delete own signals (`auth.uid() = user_id`)

**generated_emails policies:**
- SELECT: Users can view own emails (`auth.uid() = user_id`)
- INSERT: Users can insert emails for themselves (`auth.uid() = user_id`)
- DELETE: Users can delete own emails (`auth.uid() = user_id`)

Use descriptive policy names like `profiles_select_own`, `signals_insert_own`, etc.
  </action>
  <verify>SQL file exists with ENABLE ROW LEVEL SECURITY and CREATE POLICY statements for all three tables</verify>
  <done>RLS policies prevent cross-user data access: each policy checks auth.uid() = user_id or auth.uid() = id</done>
</task>

<task type="auto">
  <name>Task 3: Generate TypeScript types from schema</name>
  <files>src/types/database.ts</files>
  <action>
Create TypeScript types that match the database schema. This provides type safety when using Supabase client.

Create `src/types/database.ts` with:

```typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string
          email: string
          full_name: string | null
          avatar_url: string | null
          company_name: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          email: string
          full_name?: string | null
          avatar_url?: string | null
          company_name?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string
          full_name?: string | null
          avatar_url?: string | null
          company_name?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      signals: {
        Row: {
          id: string
          user_id: string
          company_name: string
          company_domain: string | null
          company_logo: string | null
          signal_type: 'hiring' | 'funding' | 'expansion' | 'partnership' | 'product_launch' | 'leadership_change'
          title: string
          summary: string
          source_url: string
          source_name: string
          priority: 'high' | 'medium' | 'low'
          status: 'new' | 'reviewed' | 'contacted' | 'converted' | 'dismissed'
          detected_at: string
          created_at: string
          metadata: Json
        }
        Insert: {
          id?: string
          user_id: string
          company_name: string
          company_domain?: string | null
          company_logo?: string | null
          signal_type: 'hiring' | 'funding' | 'expansion' | 'partnership' | 'product_launch' | 'leadership_change'
          title: string
          summary: string
          source_url: string
          source_name: string
          priority: 'high' | 'medium' | 'low'
          status?: 'new' | 'reviewed' | 'contacted' | 'converted' | 'dismissed'
          detected_at?: string
          created_at?: string
          metadata?: Json
        }
        Update: {
          id?: string
          user_id?: string
          company_name?: string
          company_domain?: string | null
          company_logo?: string | null
          signal_type?: 'hiring' | 'funding' | 'expansion' | 'partnership' | 'product_launch' | 'leadership_change'
          title?: string
          summary?: string
          source_url?: string
          source_name?: string
          priority?: 'high' | 'medium' | 'low'
          status?: 'new' | 'reviewed' | 'contacted' | 'converted' | 'dismissed'
          detected_at?: string
          created_at?: string
          metadata?: Json
        }
      }
      generated_emails: {
        Row: {
          id: string
          signal_id: string
          user_id: string
          subject: string
          body: string
          tone: 'professional' | 'casual' | 'enthusiastic'
          created_at: string
        }
        Insert: {
          id?: string
          signal_id: string
          user_id: string
          subject: string
          body: string
          tone: 'professional' | 'casual' | 'enthusiastic'
          created_at?: string
        }
        Update: {
          id?: string
          signal_id?: string
          user_id?: string
          subject?: string
          body?: string
          tone?: 'professional' | 'casual' | 'enthusiastic'
          created_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
  }
}
```

Update `src/lib/supabase/client.ts` and `src/lib/supabase/server.ts` to use the Database type:
- Import `Database` from `@/types/database`
- Pass as generic to `createBrowserClient<Database>()` and `createServerClient<Database>()`
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Database types exported, Supabase clients typed with Database generic</done>
</task>

</tasks>

<verification>
1. Migration files exist in `supabase/migrations/`
2. SQL syntax is valid (parseable)
3. TypeScript compiles without errors: `npx tsc --noEmit`
4. Types align with existing `src/types/index.ts` interfaces
</verification>

<success_criteria>
- [ ] `supabase/migrations/001_schema.sql` contains CREATE TABLE for profiles, signals, generated_emails
- [ ] `supabase/migrations/002_rls.sql` contains RLS policies for all tables
- [ ] `src/types/database.ts` exports Database type with all tables
- [ ] Supabase clients use Database generic for type safety
- [ ] `npx tsc --noEmit` passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
