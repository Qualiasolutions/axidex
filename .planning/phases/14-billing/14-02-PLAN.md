---
phase: 14-billing
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/app/api/billing/portal/route.ts
  - src/app/dashboard/settings/page.tsx
  - src/lib/billing.ts
  - src/middleware.ts
autonomous: true

must_haves:
  truths:
    - "User can access billing portal to manage subscription"
    - "User can view current subscription status in settings"
    - "Free tier users see upgrade prompts at limits"
    - "Usage limits are enforced based on subscription tier"
  artifacts:
    - path: "src/app/api/billing/portal/route.ts"
      provides: "Stripe billing portal session"
      exports: ["POST"]
    - path: "src/lib/billing.ts"
      provides: "Usage limit utilities"
      exports: ["checkLimit", "TIER_LIMITS", "getUserTier"]
    - path: "src/middleware.ts"
      provides: "Limit enforcement"
      contains: "checkLimit"
  key_links:
    - from: "src/app/dashboard/settings/page.tsx"
      to: "/api/billing/portal"
      via: "fetch POST for portal redirect"
      pattern: "fetch.*api/billing/portal"
    - from: "src/middleware.ts"
      to: "src/lib/billing.ts"
      via: "import checkLimit"
      pattern: "import.*billing"
---

<objective>
Implement billing portal access and usage limit enforcement.

Purpose: Allow users to manage their subscription via Stripe portal, and enforce tier-based usage limits across the app.
Output: Billing portal API, settings UI billing section, and usage limit enforcement middleware.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/14-billing/14-01-SUMMARY.md
@src/lib/stripe.ts
@src/app/dashboard/settings/page.tsx
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create billing portal API and settings UI</name>
  <files>
    src/app/api/billing/portal/route.ts
    src/app/dashboard/settings/page.tsx
  </files>
  <action>
1. Create `src/app/api/billing/portal/route.ts`:
```typescript
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { stripe } from '@/lib/stripe';

export async function POST() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Get stripe_customer_id from profile
  const { data: profile } = await supabase
    .from('profiles')
    .select('stripe_customer_id')
    .eq('id', user.id)
    .single();

  if (!profile?.stripe_customer_id) {
    return NextResponse.json({ error: 'No subscription found' }, { status: 400 });
  }

  const session = await stripe.billingPortal.sessions.create({
    customer: profile.stripe_customer_id,
    return_url: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/settings`,
  });

  return NextResponse.json({ url: session.url });
}
```

2. Update `src/app/dashboard/settings/page.tsx`:

Add a new "Billing" section between Slack and CRM sections:

```tsx
{/* Billing */}
<motion.div
  initial={{ opacity: 0, y: 10 }}
  animate={{ opacity: 1, y: 0 }}
  transition={{ duration: 0.3, delay: 0.16 }}
  className="bg-card border border-border rounded-lg p-6"
>
  <div className="flex items-center gap-3 mb-4">
    <CreditCard className="w-5 h-5 text-primary" />
    <div>
      <h2 className="font-medium text-foreground">Subscription & Billing</h2>
      <p className="text-sm text-muted-foreground">
        Manage your subscription plan and billing
      </p>
    </div>
  </div>

  {/* Show current plan */}
  <div className="p-4 bg-muted/50 rounded-lg mb-4">
    <div className="flex items-center justify-between">
      <div>
        <p className="text-sm font-medium text-foreground">
          {subscription.tier === 'free' ? 'Free Plan' :
           subscription.tier === 'pro' ? 'Pro Plan' : 'Enterprise Plan'}
        </p>
        <p className="text-xs text-muted-foreground">
          {subscription.status === 'active' && subscription.periodEnd &&
            `Renews ${new Date(subscription.periodEnd).toLocaleDateString()}`}
          {subscription.status === 'canceled' && 'Cancels at period end'}
          {subscription.tier === 'free' && 'Upgrade for more features'}
        </p>
      </div>
      {subscription.tier !== 'free' && (
        <span className="px-2 py-1 text-xs rounded-full bg-primary/10 text-primary">
          {subscription.status === 'active' ? 'Active' :
           subscription.status === 'past_due' ? 'Past Due' : 'Canceled'}
        </span>
      )}
    </div>
  </div>

  {/* Actions */}
  <div className="flex gap-3">
    {subscription.tier === 'free' ? (
      <Link href="/pricing" className="...button styles...">
        Upgrade Plan
      </Link>
    ) : (
      <button onClick={openBillingPortal} className="...button styles...">
        {billingLoading ? <Loader2 /> : 'Manage Subscription'}
      </button>
    )}
  </div>
</motion.div>
```

Add state and handler for billing:
- `subscription` state with tier, status, periodEnd
- Load subscription data in useEffect (from profiles table)
- `openBillingPortal` async function that POSTs to /api/billing/portal and redirects

Add CreditCard icon import from lucide-react.
  </action>
  <verify>
`npm run build` passes.
Visit /dashboard/settings - shows Billing section.
Current plan displayed based on profile subscription fields.
"Manage Subscription" button calls portal API.
  </verify>
  <done>
Billing portal API creates Stripe portal session.
Settings page shows subscription status and management button.
Free users see "Upgrade Plan" linking to /pricing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement usage limits enforcement</name>
  <files>
    src/lib/billing.ts
    src/middleware.ts
    src/app/api/rules/route.ts
  </files>
  <action>
1. Create `src/lib/billing.ts`:
```typescript
import { createClient } from '@/lib/supabase/server';

export const TIER_LIMITS = {
  free: {
    signals_per_month: 50,
    automation_rules: 2,
    emails_per_day: 10,
    crm_integrations: 0,
    custom_sources: 0,
  },
  pro: {
    signals_per_month: -1, // unlimited
    automation_rules: 5,
    emails_per_day: 100,
    crm_integrations: 1,
    custom_sources: 0,
  },
  enterprise: {
    signals_per_month: -1, // unlimited
    automation_rules: -1, // unlimited
    emails_per_day: -1, // unlimited
    crm_integrations: -1, // unlimited
    custom_sources: 10,
  },
} as const;

export type TierLimit = keyof typeof TIER_LIMITS.free;

export async function getUserTier(userId: string): Promise<'free' | 'pro' | 'enterprise'> {
  const supabase = await createClient();
  const { data } = await supabase
    .from('profiles')
    .select('subscription_tier, subscription_status')
    .eq('id', userId)
    .single();

  // Only active subscriptions get tier benefits
  if (!data || data.subscription_status !== 'active') {
    return 'free';
  }

  return data.subscription_tier || 'free';
}

export async function checkLimit(
  userId: string,
  limitType: TierLimit,
  currentUsage: number
): Promise<{ allowed: boolean; limit: number; tier: string }> {
  const tier = await getUserTier(userId);
  const limit = TIER_LIMITS[tier][limitType];

  // -1 means unlimited
  const allowed = limit === -1 || currentUsage < limit;

  return { allowed, limit, tier };
}

export async function getUsageCount(
  userId: string,
  resource: 'signals' | 'rules' | 'emails'
): Promise<number> {
  const supabase = await createClient();

  if (resource === 'rules') {
    const { count } = await supabase
      .from('automation_rules')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);
    return count || 0;
  }

  if (resource === 'emails') {
    // Count emails created today
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const { count } = await supabase
      .from('generated_emails')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .gte('created_at', today.toISOString());
    return count || 0;
  }

  if (resource === 'signals') {
    // Count signals this month
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);
    const { count } = await supabase
      .from('signals')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .gte('created_at', startOfMonth.toISOString());
    return count || 0;
  }

  return 0;
}
```

2. Update `src/app/api/rules/route.ts` POST handler:
Add limit check before creating rule:
```typescript
import { checkLimit, getUsageCount } from '@/lib/billing';

// In POST handler, before insert:
const currentRules = await getUsageCount(user.id, 'rules');
const { allowed, limit, tier } = await checkLimit(user.id, 'automation_rules', currentRules);

if (!allowed) {
  return NextResponse.json(
    {
      error: 'Rule limit reached',
      message: `Your ${tier} plan allows ${limit} automation rules. Upgrade for more.`,
      upgrade_url: '/pricing'
    },
    { status: 403 }
  );
}
```

3. Update `src/middleware.ts` (or create if not exists):
Add rate limiting check for email generation:
```typescript
// For /api/signals/[id]/email POST requests
// Check email limit before allowing generation
```

Note: If middleware.ts doesn't exist, check if limits should be enforced at the API route level instead (inside src/app/api/signals/[id]/email/route.ts).
  </action>
  <verify>
`npm run build` passes.
`npx tsc --noEmit` passes.
Create automation rule as free user - should work up to limit.
Try creating beyond limit - should return 403 with upgrade message.
  </verify>
  <done>
TIER_LIMITS defines resource limits per tier.
checkLimit and getUsageCount utilities work.
Rules API enforces automation_rules limit.
Email generation respects daily limit.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Types compile: `npx tsc --noEmit`
3. Settings page shows billing section with current plan
4. Billing portal opens for subscribed users
5. Usage limits enforced on rule creation
</verification>

<success_criteria>
- [ ] POST /api/billing/portal creates portal session
- [ ] Settings page displays current subscription tier and status
- [ ] Free users see "Upgrade Plan" button
- [ ] Subscribed users see "Manage Subscription" button
- [ ] TIER_LIMITS defines limits for free/pro/enterprise
- [ ] Rules API returns 403 when limit exceeded
- [ ] Error response includes upgrade_url for UX
</success_criteria>

<output>
After completion, create `.planning/phases/14-billing/14-02-SUMMARY.md`
</output>
