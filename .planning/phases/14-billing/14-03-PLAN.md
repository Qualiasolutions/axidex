---
phase: 14-billing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/signals/[id]/email/route.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Free tier users cannot generate more than 10 emails per day"
    - "Users exceeding limit receive 403 with upgrade URL"
    - "Pro and enterprise tier users have higher/unlimited email limits"
  artifacts:
    - path: "src/app/api/signals/[id]/email/route.ts"
      provides: "Email generation with limit enforcement"
      contains: "checkLimit"
  key_links:
    - from: "src/app/api/signals/[id]/email/route.ts"
      to: "src/lib/billing.ts"
      via: "import checkLimit, getUsageCount"
      pattern: "import.*checkLimit.*from.*billing"
---

<objective>
Enforce emails_per_day limit in email generation route.

Purpose: Close verification gap where free tier users can generate unlimited emails (should be capped at 10/day per TIER_LIMITS).
Output: Email route returns 403 with upgrade_url when daily limit exceeded.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-billing/14-VERIFICATION.md
@src/lib/billing.ts
@src/app/api/rules/route.ts (pattern reference for limit enforcement)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email generation limit enforcement</name>
  <files>src/app/api/signals/[id]/email/route.ts</files>
  <action>
Add limit enforcement to the email generation route following the established pattern from rules API (Decision D051):

1. Add imports at top of file:
   - Import `checkLimit, getUsageCount` from `@/lib/billing`

2. After user auth check (line ~50), before parsing request body, add limit check:
   ```typescript
   // Check email generation limit
   const currentEmailCount = await getUsageCount(user.id, 'emails');
   const { allowed, limit, tier } = await checkLimit(user.id, 'emails_per_day', currentEmailCount);

   if (!allowed) {
     return NextResponse.json(
       {
         error: 'Daily email generation limit reached',
         limit,
         current: currentEmailCount,
         tier,
         upgrade_url: '/pricing',
       },
       { status: 403 }
     );
   }
   ```

3. Keep all existing functionality (signal fetch, email generation, save to DB) unchanged.

Pattern reference: See src/app/api/rules/route.ts POST handler for identical limit enforcement pattern.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no type errors
2. Grep for checkLimit import: `grep -n "checkLimit" src/app/api/signals/[id]/email/route.ts` shows import line
3. Grep for limit check: `grep -n "emails_per_day" src/app/api/signals/[id]/email/route.ts` shows limit check
  </verify>
  <done>
Email route enforces emails_per_day limit. Free tier users get 403 with upgrade_url after 10 emails/day.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Email route imports billing utilities
3. Limit check occurs before email generation (not after)
4. 403 response includes: error, limit, current, tier, upgrade_url
</verification>

<success_criteria>
- Email route enforces emails_per_day limit from TIER_LIMITS
- Free tier: 10/day, Pro: 100/day, Enterprise: unlimited (-1)
- Response matches rules API pattern (403 with upgrade_url)
- No regressions to existing email generation functionality
</success_criteria>

<output>
After completion, create `.planning/phases/14-billing/14-03-SUMMARY.md`
Then re-run verification: `/gsd:verify-work 14` to confirm gap closed.
</output>
