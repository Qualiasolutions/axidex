---
phase: 07-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - sentry.client.config.ts
  - sentry.server.config.ts
  - sentry.edge.config.ts
  - next.config.ts
  - src/app/global-error.tsx
  - worker/pyproject.toml
  - worker/src/sentry_setup.py
  - worker/src/main.py
  - worker/src/config.py
autonomous: true

user_setup:
  - service: sentry
    why: "Error tracking and monitoring"
    env_vars:
      - name: SENTRY_DSN
        source: "Sentry Dashboard -> Project Settings -> Client Keys (DSN)"
      - name: SENTRY_AUTH_TOKEN
        source: "Sentry Dashboard -> Settings -> Auth Tokens -> Create Token (org:ci scope)"
    dashboard_config:
      - task: "Create Sentry project for Next.js (if not exists)"
        location: "Sentry Dashboard -> Create Project -> Next.js"
      - task: "Create Sentry project for Python (if not exists)"
        location: "Sentry Dashboard -> Create Project -> Python"

must_haves:
  truths:
    - "Frontend errors appear in Sentry dashboard with stack traces"
    - "Worker exceptions appear in Sentry with context"
    - "Unhandled promise rejections are captured on client"
    - "Server-side errors include request context"
  artifacts:
    - path: "sentry.client.config.ts"
      provides: "Browser-side Sentry initialization"
      contains: "Sentry.init"
    - path: "sentry.server.config.ts"
      provides: "Server-side Sentry initialization"
      contains: "Sentry.init"
    - path: "worker/src/sentry_setup.py"
      provides: "Python Sentry initialization"
      contains: "sentry_sdk.init"
  key_links:
    - from: "src/app/global-error.tsx"
      to: "Sentry.captureException"
      via: "error boundary capture"
      pattern: "captureException"
    - from: "worker/src/main.py"
      to: "worker/src/sentry_setup.py"
      via: "import at startup"
      pattern: "from .sentry_setup import"
---

<objective>
Integrate Sentry SDK into both Next.js frontend and Python worker for comprehensive error tracking and monitoring.

Purpose: Enable proactive error detection across the entire application stack - frontend errors, API route failures, and worker exceptions all flow into Sentry for debugging and alerting.

Output: Sentry configuration files for Next.js (client/server/edge) and Python worker, with automatic error capture and context enrichment.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/layout.tsx
@src/app/global-error.tsx
@worker/src/main.py
@worker/src/config.py
@worker/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure Sentry for Next.js</name>
  <files>
    package.json
    sentry.client.config.ts
    sentry.server.config.ts
    sentry.edge.config.ts
    next.config.ts
    src/app/global-error.tsx
  </files>
  <action>
    1. Install @sentry/nextjs SDK:
       ```bash
       npm install @sentry/nextjs
       ```

    2. Create `sentry.client.config.ts` in project root:
       ```typescript
       import * as Sentry from "@sentry/nextjs";

       Sentry.init({
         dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
         environment: process.env.NODE_ENV,

         // Performance monitoring
         tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,

         // Session replay for debugging
         replaysSessionSampleRate: 0.1,
         replaysOnErrorSampleRate: 1.0,

         integrations: [
           Sentry.replayIntegration(),
         ],

         // Don't send errors in development unless DSN is set
         enabled: !!process.env.NEXT_PUBLIC_SENTRY_DSN,
       });
       ```

    3. Create `sentry.server.config.ts` in project root:
       ```typescript
       import * as Sentry from "@sentry/nextjs";

       Sentry.init({
         dsn: process.env.SENTRY_DSN,
         environment: process.env.NODE_ENV,
         tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,
         enabled: !!process.env.SENTRY_DSN,
       });
       ```

    4. Create `sentry.edge.config.ts` in project root:
       ```typescript
       import * as Sentry from "@sentry/nextjs";

       Sentry.init({
         dsn: process.env.SENTRY_DSN,
         environment: process.env.NODE_ENV,
         tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,
         enabled: !!process.env.SENTRY_DSN,
       });
       ```

    5. Update `next.config.ts` to wrap with Sentry:
       - Import withSentryConfig from @sentry/nextjs
       - Wrap existing config with withSentryConfig
       - Add Sentry build options: hideSourceMaps: true, disableLogger: true

    6. Update `src/app/global-error.tsx` to capture with Sentry:
       - Import * as Sentry from "@sentry/nextjs"
       - Add useEffect to call Sentry.captureException(error) when error prop changes
       - Keep existing UI (the file already has error boundary UI)

    IMPORTANT: Use NEXT_PUBLIC_SENTRY_DSN for client config (browser needs access), SENTRY_DSN for server/edge.
  </action>
  <verify>
    - `npm run build` succeeds without Sentry errors
    - `npx tsc --noEmit` passes
    - sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts exist
    - next.config.ts includes withSentryConfig wrapper
  </verify>
  <done>
    @sentry/nextjs installed and configured for client, server, and edge runtimes. Global error boundary captures and reports exceptions to Sentry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install and configure Sentry for Python worker</name>
  <files>
    worker/pyproject.toml
    worker/src/sentry_setup.py
    worker/src/main.py
    worker/src/config.py
  </files>
  <action>
    1. Add sentry-sdk to worker/pyproject.toml dependencies:
       ```toml
       "sentry-sdk>=2.0",
       ```

    2. Add sentry_dsn to worker/src/config.py Settings class:
       ```python
       sentry_dsn: Optional[str] = None
       ```

    3. Create worker/src/sentry_setup.py:
       ```python
       import sentry_sdk
       from sentry_sdk.integrations.logging import LoggingIntegration
       import logging
       from .config import get_settings

       def init_sentry():
           """Initialize Sentry for the worker process."""
           settings = get_settings()

           if not settings.sentry_dsn:
               return False

           sentry_sdk.init(
               dsn=settings.sentry_dsn,
               environment="production",

               # Performance monitoring
               traces_sample_rate=0.1,

               # Capture INFO+ logs as breadcrumbs, WARNING+ as events
               integrations=[
                   LoggingIntegration(
                       level=logging.INFO,
                       event_level=logging.WARNING,
                   ),
               ],

               # Add worker context to all events
               release="axidex-worker@0.1.0",
           )

           # Set default tags
           sentry_sdk.set_tag("service", "worker")

           return True
       ```

    4. Update worker/src/main.py to initialize Sentry at startup:
       - Add import: `from .sentry_setup import init_sentry`
       - Call `init_sentry()` at the start of `main()` function, BEFORE log.info("worker_starting")
       - Wrap the scraper exception handling with Sentry context:
         ```python
         except Exception as e:
             sentry_sdk.capture_exception(e)
             log.error("scraper_failed", scraper=scraper.name, error=str(e))
         ```
       - Add `import sentry_sdk` to imports

    5. Add Sentry context to scraper runs - in run_scrapers(), add context before the loop:
       ```python
       with sentry_sdk.configure_scope() as scope:
           scope.set_context("scraper_run", {
               "ai_enabled": settings.ai_enabled,
               "model": settings.openai_model,
           })
       ```

    IMPORTANT: Worker uses structlog for logging. Sentry's LoggingIntegration works with stdlib logging which structlog can output to. The integration captures structlog output.
  </action>
  <verify>
    - worker/pyproject.toml includes sentry-sdk
    - worker/src/sentry_setup.py exists with init_sentry function
    - worker/src/config.py includes sentry_dsn setting
    - `grep -r "init_sentry" worker/src/main.py` finds the import and call
  </verify>
  <done>
    sentry-sdk installed in Python worker. Sentry initializes on startup, captures exceptions with scraper context, and integrates with existing structlog logging.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes for Next.js
2. `npx tsc --noEmit` passes
3. All Sentry config files exist (client, server, edge for Next.js; sentry_setup.py for worker)
4. Worker main.py imports and calls init_sentry()
5. Global error boundary includes Sentry.captureException
</verification>

<success_criteria>
- @sentry/nextjs integrated in Next.js with client/server/edge configs
- sentry-sdk integrated in Python worker with LoggingIntegration
- Both applications gracefully handle missing SENTRY_DSN (disabled but no errors)
- Scraper exceptions captured with context (scraper name, AI model)
- Build and type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-observability/07-01-SUMMARY.md`
</output>
