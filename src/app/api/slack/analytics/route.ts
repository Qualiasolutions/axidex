import { createClient } from "@/lib/supabase/server";
import { NextResponse } from "next/server";

type Period = "today" | "week" | "month" | "quarter";

// POST /api/slack/analytics - Send analytics summary to Slack
export async function POST(request: Request) {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Get period from request body
  const body = await request.json().catch(() => ({}));
  const period: Period = body.period || "month";

  // Get user's Slack settings
  const { data: profile, error: profileError } = await supabase
    .from("profiles")
    .select("slack_access_token, slack_channel_id, slack_enabled")
    .eq("id", user.id)
    .single();

  if (profileError || !profile) {
    return NextResponse.json(
      { error: "Failed to load profile" },
      { status: 500 }
    );
  }

  if (!profile.slack_access_token || !profile.slack_channel_id) {
    return NextResponse.json(
      { error: "Slack not configured. Please connect Slack first." },
      { status: 400 }
    );
  }

  // Calculate date range
  const now = new Date();
  let startDate: Date;
  let periodLabel: string;

  switch (period) {
    case "today":
      startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      periodLabel = "Today";
      break;
    case "week":
      startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      periodLabel = "This Week";
      break;
    case "quarter":
      startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      periodLabel = "This Quarter";
      break;
    case "month":
    default:
      startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      periodLabel = "This Month";
  }

  // Fetch analytics data
  const { data: signals } = await supabase
    .from("signals")
    .select("*")
    .or(`user_id.eq.${user.id},user_id.is.null`)
    .gte("created_at", startDate.toISOString());

  const { data: emails } = await supabase
    .from("generated_emails")
    .select("*")
    .eq("user_id", user.id)
    .gte("created_at", startDate.toISOString());

  // Calculate metrics
  const totalSignals = signals?.length || 0;
  const newSignals = signals?.filter((s) => s.status === "new").length || 0;
  const highPriority = signals?.filter((s) => s.priority === "high").length || 0;
  const emailsDrafted = emails?.length || 0;
  const emailsSent = 0; // TODO: Add status tracking to emails table

  // Count by type
  const signalsByType: Record<string, number> = {};
  signals?.forEach((s) => {
    signalsByType[s.signal_type] = (signalsByType[s.signal_type] || 0) + 1;
  });

  // Format type breakdown
  const typeBreakdown = Object.entries(signalsByType)
    .map(([type, count]) => `â€¢ ${type.replace("_", " ")}: ${count}`)
    .join("\n") || "â€¢ No signals yet";

  // Build Slack message
  const blocks = [
    {
      type: "header",
      text: {
        type: "plain_text",
        text: `ðŸ“Š Analytics Report - ${periodLabel}`,
        emoji: true,
      },
    },
    {
      type: "section",
      fields: [
        {
          type: "mrkdwn",
          text: `*Total Signals*\n${totalSignals}`,
        },
        {
          type: "mrkdwn",
          text: `*New Signals*\n${newSignals}`,
        },
        {
          type: "mrkdwn",
          text: `*High Priority*\n${highPriority}`,
        },
        {
          type: "mrkdwn",
          text: `*Emails Drafted*\n${emailsDrafted}`,
        },
      ],
    },
    {
      type: "section",
      fields: [
        {
          type: "mrkdwn",
          text: `*Emails Sent*\n${emailsSent}`,
        },
        {
          type: "mrkdwn",
          text: `*Conversion Rate*\n${totalSignals > 0 ? Math.round((emailsSent / totalSignals) * 100) : 0}%`,
        },
      ],
    },
    {
      type: "divider",
    },
    {
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*Signals by Type*\n${typeBreakdown}`,
      },
    },
    {
      type: "context",
      elements: [
        {
          type: "mrkdwn",
          text: `Generated by <https://axidex.vercel.app/dashboard/analytics|Axidex> at ${new Date().toLocaleString()}`,
        },
      ],
    },
  ];

  // Send to Slack
  const slackResponse = await fetch("https://slack.com/api/chat.postMessage", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${profile.slack_access_token}`,
    },
    body: JSON.stringify({
      channel: profile.slack_channel_id,
      blocks,
      text: `Analytics Report - ${periodLabel}`,
    }),
  });

  const slackResult = await slackResponse.json();

  if (!slackResult.ok) {
    return NextResponse.json(
      { error: `Slack error: ${slackResult.error}` },
      { status: 500 }
    );
  }

  return NextResponse.json({
    success: true,
    message: "Analytics report sent to Slack!",
  });
}
